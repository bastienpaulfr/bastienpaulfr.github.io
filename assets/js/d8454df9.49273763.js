"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[64],{3905:function(e,t,r){r.d(t,{Zo:function(){return s},kt:function(){return d}});var n=r(7294);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function u(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function a(e,t){if(null==e)return{};var r,n,i=function(e,t){if(null==e)return{};var r,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(i[r]=e[r]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(i[r]=e[r])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):u(u({},t),e)),r},s=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var r=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,s=a(e,["components","mdxType","originalType","parentName"]),m=c(r),d=i,f=m["".concat(l,".").concat(d)]||m[d]||p[d]||o;return r?n.createElement(f,u(u({ref:t},s),{},{components:r})):n.createElement(f,u({ref:t},s))}));function d(e,t){var r=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=r.length,u=new Array(o);u[0]=m;var a={};for(var l in t)hasOwnProperty.call(t,l)&&(a[l]=t[l]);a.originalType=e,a.mdxType="string"==typeof e?e:i,u[1]=a;for(var c=2;c<o;c++)u[c]=r[c];return n.createElement.apply(null,u)}return n.createElement.apply(null,r)}m.displayName="MDXCreateElement"},646:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return a},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return s},toc:function(){return p},default:function(){return d}});var n=r(7462),i=r(3366),o=(r(7294),r(3905)),u=["components"],a={title:"Mutex Locker",date:new Date("2014-08-04T13:02:32.000Z"),draft:!1},l=void 0,c={permalink:"/blog/mutex-locker",editUrl:"https://github.com/bastienpaulfr/bastienpaulfr.github.io/edit/master/website/blog/blog/mutex-locker.md",source:"@site/blog/mutex-locker.md",title:"Mutex Locker",description:"Pr\xe9ambule",date:"2014-08-04T13:02:32.000Z",formattedDate:"August 4, 2014",tags:[],readingTime:1.085,truncated:!1,authors:[],prevItem:{title:"Assert Statique",permalink:"/blog/static-assert"},nextItem:{title:"Singleton",permalink:"/blog/singleton"}},s={authorsImageUrls:[]},p=[{value:"Pr\xe9ambule",id:"pr\xe9ambule",children:[]},{value:"Principe",id:"principe",children:[]},{value:"Conclusion",id:"conclusion",children:[]}],m={toc:p};function d(e){var t=e.components,r=(0,i.Z)(e,u);return(0,o.kt)("wrapper",(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h2",{id:"pr\xe9ambule"},"Pr\xe9ambule"),(0,o.kt)("p",null,"Le mutex locker fait partie du concept de ",(0,o.kt)("a",{parentName:"p",href:"http://fr.wikipedia.org/wiki/RAII"},"RAII"),". Cette acronyme vient de l\u2019anglais Resource Acquisition Is Initialization. C\u2019est une technique de programmation qui permet de s\u2019assurer que la ressource acquise sera bien lib\xe9r\xe9e \xe0 la fin de la vie d\u2019un objet."),(0,o.kt)("h2",{id:"principe"},"Principe"),(0,o.kt)("p",null,"Appliqu\xe9 au mutex, ce principe consiste \xe0 bloquer un mutex lors de la cr\xe9ation d\u2019un objet et de le lib\xe9rer lors de sa destruction. On peut imaginer la cr\xe9ation d\u2019un objet sp\xe9cifique : le ",(0,o.kt)("inlineCode",{parentName:"p"},"MutexLocker"),".  Il faudrait qu\u2019il puisse prendre un mutex lors de sa cr\xe9ation et le lib\xe9rer lors de sa destruction. Son constructeur va donc prendre le mutex et son destructeur le d\xe9truire."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"class MutexLocker {\n    public :\n        MutexLocker(Mutex& mutex): m_mutex(mutex) {\n            m_mutex.Lock();\n        }\n        virtual ~MutexLocker(){\n            m_mutex.Unlock();\n        }\n\n    private:\n        Mutex& m_mutex;\n};\n")),(0,o.kt)("p",null,"Son utilisation proc\xe8de comme suit :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-c++"},"{\n    Mutex mutex;\n    MutexLocker locker(mutex);\n    /* Maintenant le mutex est pris. Le code critique peut \xeatre ex\xe9cut\xe9. */\n}\n")),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Son utilisation est justifi\xe9 quand des exceptions peuvent arriver \xe0 tout moment. A ce moment, le mutex est assur\xe9 d\u2019\xeatre lib\xe9r\xe9 \xe0 la fin de la port\xe9e du code lorsque le locker est d\xe9truit. D\u2019une mani\xe8re g\xe9n\xe9rale, il est bon de l\u2019utiliser tout le temps pour \xe9viter de tomber dans des cas d\u2019erreur difficiles \xe0 d\xe9tecter."))}d.isMDXComponent=!0}}]);