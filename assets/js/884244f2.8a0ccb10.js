"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[725],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return u}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=d(n),u=o,h=m["".concat(s,".").concat(u)]||m[u]||c[u]||r;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var d=2;d<r;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1144:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},assets:function(){return p},toc:function(){return c},default:function(){return u}});var a=n(7462),o=n(3366),r=(n(7294),n(3905)),i=["components"],l={title:"How to make a good converter",date:new Date("2022-07-08T12:55:46.000Z"),draft:!1},s="Converters",d={permalink:"/blog/converters",editUrl:"https://github.com/bastienpaulfr/bastienpaulfr.github.io/edit/master/website/blog/blog/converters.md",source:"@site/blog/converters.md",title:"How to make a good converter",description:"Purpose",date:"2022-07-08T12:55:46.000Z",formattedDate:"July 8, 2022",tags:[],readingTime:4.83,truncated:!1,authors:[],nextItem:{title:"Add a new line at the end of each text files tracked by git",permalink:"/blog/nl-at-eof"}},p={authorsImageUrls:[]},c=[{value:"Purpose",id:"purpose",children:[{value:"DIP",id:"dip",children:[]},{value:"SRP",id:"srp",children:[]}]},{value:"Implementation",id:"implementation",children:[{value:"Simple extension method",id:"simple-extension-method",children:[]},{value:"Simple class",id:"simple-class",children:[]},{value:"We need an additional contributor",id:"we-need-an-additional-contributor",children:[]},{value:"We need a converter with additional parameters",id:"we-need-a-converter-with-additional-parameters",children:[]},{value:"\u2705\xa0Do",id:"do",children:[]},{value:"\u274c\xa0Don\u2019t",id:"dont",children:[]}]},{value:"Naming",id:"naming",children:[{value:"Class",id:"class",children:[]},{value:"Extension method",id:"extension-method",children:[]}]},{value:"File",id:"file",children:[]},{value:"Layers",id:"layers",children:[{value:"Data",id:"data",children:[]},{value:"UI",id:"ui",children:[]}]}],m={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,i);return(0,r.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"purpose"},"Purpose"),(0,r.kt)("p",null,"The purpose of the ",(0,r.kt)("strong",{parentName:"p"},"Converter")," pattern is to provide a generic, common way of bidirectional conversion between corresponding types, allowing a clean implementation in which the types do not need to be aware of each other."),(0,r.kt)("p",null,"In plain words, the ",(0,r.kt)("strong",{parentName:"p"},"Converter")," pattern makes it easy to map instances of one class into instances of another class."),(0,r.kt)("p",null,"We're making use of Converter to map models when they are ",(0,r.kt)("strong",{parentName:"p"},"propagating between layers")," (API, Data, Domain, Presentation) to make them ",(0,r.kt)("strong",{parentName:"p"},"convenient to work with on a specific layer")," and do ",(0,r.kt)("strong",{parentName:"p"},"not spread extra dependencies to other layers"),"."),(0,r.kt)("h3",{id:"dip"},"DIP"),(0,r.kt)("p",null,"Conversion is here to comply with dependency inversion principle. Domain layer only know about itself. ",(0,r.kt)("strong",{parentName:"p"},"UI")," ",(0,r.kt)("strong",{parentName:"p"},"layer")," needs to convert ",(0,r.kt)("strong",{parentName:"p"},"UI")," ",(0,r.kt)("strong",{parentName:"p"},"model")," into ",(0,r.kt)("strong",{parentName:"p"},"Domain")," ",(0,r.kt)("strong",{parentName:"p"},"DTO")," to deal with ",(0,r.kt)("strong",{parentName:"p"},"Domain")," ",(0,r.kt)("strong",{parentName:"p"},"layer"),". ",(0,r.kt)("strong",{parentName:"p"},"Data layer")," needs to convert ",(0,r.kt)("strong",{parentName:"p"},"Data model")," into ",(0,r.kt)("strong",{parentName:"p"},"Domain dto")," to deals with ",(0,r.kt)("strong",{parentName:"p"},"Domain layer"),"."),(0,r.kt)("h3",{id:"srp"},"SRP"),(0,r.kt)("p",null,"We want to extract conversion methods to comply with Single Responsibility Principle. Putting conversion logic in its own scope, makes it easier to test. Extracting conversion logic from other classes, ensure that they focus on their business and not in conversion logic."),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,"Actually, there are different uses cases that we should handle that would trigger different implementations"),(0,r.kt)("h3",{id:"simple-extension-method"},"Simple extension method"),(0,r.kt)("p",null,"For the simpler cases, it is advised to stick with ",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it"},"YAGNI")," principle and have only an extension method in a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"<source type>To<destination type>Converter.kt")," because you aren\u2019t gonna need a class."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"fun MyModel.toMyOtherModel() = MyOtherModel(\n   attr1 = id,\n   attr2 = name,\n   //...\n)\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"But I need to handle lists of items !"),(0,r.kt)("p",{parentName:"li"},"Kotlin is here to help thanks to the ",(0,r.kt)("inlineCode",{parentName:"p"},"map{}")," extension to collection classes"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Given this converter method\nfun MyModel.toMyOtherModel(): MyOtherModel {}\n// And the fact that we have a list of objects to convert\nval myModels = listOf(myModel1, myModel2, myModel3)\n\n// Convertion could be done with map extension method.\nval myOtherModels = myModels.map { it.toMyOtherModel() }\n")),(0,r.kt)("p",null,"\u274c Do not call extension method from domain layer."),(0,r.kt)("h3",{id:"simple-class"},"Simple class"),(0,r.kt)("p",null,"You can create a converter class if you want to use Injection features or if you need additional contributors. You should always avoid to use kotlin ",(0,r.kt)("inlineCode",{parentName:"p"},"objects")," because using a Singleton is often a code smell. It is a ressource killer because never destoyed. They are hiding dependencies and states and they are making your application more coupled."),(0,r.kt)("h4",{id:"example"},"Example"),(0,r.kt)("p",null,"\ud83d\udc49\xa0Create the ",(0,r.kt)("strong",{parentName:"p"},"converter class")," that can be injected thanks to ",(0,r.kt)("inlineCode",{parentName:"p"},"@Inject")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class ATypeToAnotherTypeConverter @Inject constructor()\n    fun convert(from: AType): AnotherType = when (this) {\n            AType.A-> AnotherType.A\n            AType.B-> AnotherType.B\n        }\n}\n")),(0,r.kt)("h3",{id:"we-need-an-additional-contributor"},"We need an additional contributor"),(0,r.kt)("p",null,"Sometimes you\u2019ll need an additional contributor like a ",(0,r.kt)("inlineCode",{parentName:"p"},"LocaleProvider")," or a ",(0,r.kt)("inlineCode",{parentName:"p"},"DateProvider")),(0,r.kt)("p",null,"\ud83d\udc49\xa0Inject them in the converter class"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"class DomainDtoToUiModel @Inject constructor(\n    // here timezone is dynamic, it is retrieved from a provider\n    timeZoneProvider: TimeZoneProvider\n) {\n\n    // Here date format is static. To make is dynamic, format can be injected in constructor.\n        private val simpleDateFormat = SimpleDateFormat(/*...*/)\n\n      fun convert(dto: DomainDto): UiModel {\n        return UiModel(\n            displayDate = simpleDateFormat.format(dto.currentDate, timeZoneProvider.getLocalTimeZone())\n        )\n        }\n{\n")),(0,r.kt)("h3",{id:"we-need-a-converter-with-additional-parameters"},"We need a converter with additional parameters"),(0,r.kt)("p",null,"Most of the time, it is an unexpected case. Converters have 1:1 relationship."),(0,r.kt)("p",null,"\ud83d\udca1 If logic begins to be complex, or you\u2019re creating several implementations of an interface, you should consider using a ",(0,r.kt)("a",{parentName:"p",href:"https://refactoring.guru/design-patterns/factory-method"},"Factory")," or a ",(0,r.kt)("a",{parentName:"p",href:"https://refactoring.guru/design-patterns/builder"},"Builder")," instead."),(0,r.kt)("p",null,"You might want to convert a domain DTO in a model of UI or data layer, then use the last model along a factory to create more complex instance."),(0,r.kt)("h3",{id:"do"},"\u2705\xa0Do"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Place converter in UI or Data layer (along ViewModel or DataSource)"),(0,r.kt)("li",{parentName:"ul"},"Make converter as simple as possible")),(0,r.kt)("h3",{id:"dont"},"\u274c\xa0Don\u2019t"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"\ud83e\udde8\xa0Conversion method can crash"),(0,r.kt)("li",{parentName:"ul"},"Call converter from Domain layer"),(0,r.kt)("li",{parentName:"ul"},"Implement complex logic"),(0,r.kt)("li",{parentName:"ul"},"Extend very common classes like ",(0,r.kt)("inlineCode",{parentName:"li"},"String"),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Long")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Int"))),(0,r.kt)("h2",{id:"naming"},"Naming"),(0,r.kt)("h3",{id:"class"},"Class"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"<source type>To<destination type>Converter"),", e.g.:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"LocalCardToCardConverter")," (LocalCard \ud83d\udc49 Card)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"RequestToLocalRequestConverter")," (Request \ud83d\udc49 LocalRequest)")),(0,r.kt)("p",null,"\ud83d\udca1 It should be clear what types converters are converting. This is the reason why the ",(0,r.kt)("strong",{parentName:"p"},"source")," type ",(0,r.kt)("strong",{parentName:"p"},"and")," the ",(0,r.kt)("strong",{parentName:"p"},"destination")," type are mentioned."),(0,r.kt)("h3",{id:"extension-method"},"Extension method"),(0,r.kt)("p",null,"The extension method used for converting the extended object into the target one should be named : ",(0,r.kt)("inlineCode",{parentName:"p"},"fun Model.toNameOfTargetedClass(){}")),(0,r.kt)("p",null,"It should belong to a file named ",(0,r.kt)("inlineCode",{parentName:"p"},"<source type>To<destination type>Converter.kt")),(0,r.kt)("p",null,"\ud83d\udca1 The ",(0,r.kt)("strong",{parentName:"p"},"destination type")," of the converter extension method should be crystal clear. A model can also be converted in ",(0,r.kt)("strong",{parentName:"p"},"several")," kind of classes. This is the reason why methods like ",(0,r.kt)("inlineCode",{parentName:"p"},".toDomainModel()")," or ",(0,r.kt)("inlineCode",{parentName:"p"},".toDataModel()")," are not encouraged."),(0,r.kt)("p",null,"Given this data classes:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Data layer\ndata class RemoteTypeOfMyObject()\n\n// Domain layer\ndata class MyAwesomeData()\n\n// UI layer\ndata class AwesomeUiState()\n")),(0,r.kt)("p",null,"Then we should have these extension methods"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},"// Data layer\nfun RemoteTypeOfMyObject.toMyAwsomeData(): MyAwesomeData\nfun MyAwesomeData.toRemoteTypeOfMyObject(): RemoteTypeOfMyObject\n\n// UI Layer\nfun AwsomeUiState.toMyAwsomeData(): MyAwesomeData\nfun MyAwesomeData.toAwesomeUiState(): AwesomeUiState\n")),(0,r.kt)("h2",{id:"file"},"File"),(0,r.kt)("p",null,"Converter class or methods should be placed into their belonging layer, not in the domain one."),(0,r.kt)("p",null,"\u26a0\ufe0f Domain layer should not know about classes that are in UI or in Data layer."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"root\n  |- Data\n  |    |-...- RemoteTypeOfMyObject.kt\n  |    |-...- RemoteTypeOfMyObjectConverter.kt  <- Converter is here\n  |\n  |- Domain\n  |     /!\\ No converters here /!\\\n  |\n  |- UI\n      |-...- AwsomeUiState.kt\n      |-...- AwsomeUiStateConverter.kt <- Converter is here\n")),(0,r.kt)("h2",{id:"layers"},"Layers"),(0,r.kt)("h3",{id:"data"},"Data"),(0,r.kt)("p",null,"Converters in data layer should be called from data sources. Repositories are dealing with business models."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"A source is part of the external world : everything that you don\u2019t own and that you want to scope into the smallest possible part. No-one should know about your source implementation details except the source itself. So it should be responsible to expose a model that the consumer can undestand without having to know the implementation details of that source")),(0,r.kt)("h3",{id:"ui"},"UI"),(0,r.kt)("p",null,"Converters in UI layer should be called from ViewModels. They are the bridge between UI model and business rules (implemented in UseCases)"))}u.isMDXComponent=!0}}]);